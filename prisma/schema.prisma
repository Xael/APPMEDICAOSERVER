// ./prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NOVO MODELO PARA UNIDADES DE MEDIDA
model Unit {
  id        Int      @id @default(autoincrement())
  name      String   // Ex: "Metros Quadrados", "Horas", "Quantidade"
  symbol    String   // Ex: "m²", "h", "qtd"
  services  Service[]
}

model Service {
  id        Int      @id @default(autoincrement())
  name      String   @unique // <-- ADICIONE APENAS O @unique AQUI
  unitId    Int
  unit      Unit     @relation(fields: [unitId], references: [id])
  locations LocationService[]
}

model Location {
  id            Int      @id @default(autoincrement())
  city          String   // O frontend chama isso de 'contractGroup'
  name          String
  lat           Float?
  lng           Float?

  // CAMPO 'area' REMOVIDO
  
  records       Record[]
  
  // A RELAÇÃO COM SERVIÇOS AGORA É ATRAVÉS DA TABELA 'LocationService'
  services      LocationService[]
}

// NOVA TABELA DE JUNÇÃO PARA ARMAZENAR MEDIÇÕES
model LocationService {
  locationId    Int
  serviceId     Int
  measurement   Float    // A medição específica (metragem, tempo, qtd)

  location      Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  service       Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([locationId, serviceId]) // Chave primária composta
}

// --- OUTROS MODELOS (provavelmente já existem, mantenha como estão) ---

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  name          String
  password      String
  role          String   // ADMIN, OPERATOR, FISCAL
  assignments   Json?
  records       Record[]
  auditLogs     AuditLog[]
}

model Record {
  id              Int      @id @default(autoincrement())
  operatorId      Int
  operatorName    String
  serviceType     String
  serviceUnit     String
  locationId      Int?
  locationName    String
  contractGroup   String
  locationArea    Float?
  gpsUsed         Boolean
  startTime       DateTime
  endTime         DateTime?
  beforePhotos    String[]
  afterPhotos     String[]
  
  operator        User     @relation(fields: [operatorId], references: [id])
  location        Location? @relation(fields: [locationId], references: [id])
}

model Goal {
  id            Int      @id @default(autoincrement())
  contractGroup String
  month         String
  targetArea    Float
}

model ContractConfig {
  id             Int    @id @default(autoincrement())
  contractGroup  String @unique
  cycleStartDay  Int
}

model AuditLog {
  id            Int      @id @default(autoincrement())
  timestamp     DateTime @default(now())
  adminId       Int
  adminUsername String
  action        String   // UPDATE or DELETE
  recordId      Int
  details       String

  admin         User     @relation(fields: [adminId], references: [id])
}

